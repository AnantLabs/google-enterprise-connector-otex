#summary SQL queries executed by the Livelink connector
#labels Phase-Deploy,UnderConstruction

<wiki:toc max_depth="1" />

= Note about Syntax =

Due to the constraints of the Livelink API, all queries have a table correlation named "`a`" appended to the table expression, and all queries must have a where clause. Values specified at runtime are shown using the invented synax `$parameter`. Many of these parameters are taken from the connector properties of the same name, e.g., `$includedLocationNodes` is the Items to Index property name.

Optional pieces of a query are shown in square brackets: `[ and DataID in ($excludedLocationNodes)  ]`. Exclusive choices are separated by a vertical bar: `[ 1=1 | ModifyDate > $modifyDate ]`.

All queries are submitted as literal strings without SQL parameters. The Livelink API may prepare a statement before execution, but the prepared statement is not cached for future execution.

= Configuration Queries =

These queries are executed when validating the configuration form in the admin console.

  # Determine the database type. If the servtype property is not configured, then the following two queries are run to determine whether Livelink is backed by Oracle or SQL Server.
{{{
select 42 from KDual a where 1=1

select 42 from dual a where 1=1
}}}
  # If Items to Index are specified or hidden items are not to be indexed, ensure that the DTreeAncestors table is not empty. The first query is used with Oracle, and the second with SQL Server.
{{{
select DataID from DTreeAncestors a where rownum = 1

select TOP 1 DataID from DTreeAncestors a where 1=1
}}}
  # If Items to Index are specified, ensure that at least one of the items to index appears in the DTreeAncestors table.
{{{
select min(ModifyDate) as minModifyDate 
from DTree a
where DataID in (select DataID from DTreeAncestors where AncestorID in ($ancestorNodes)) 
    or DataID in ($includedLocationNodes)
}}}
  # If Items to Index are specified or hidden items are not to be indexed, ensure that the DTreeAncestors table contains everything in the Enterprise workspace. The first query is used with Oracle, and the second with SQL Server.
{{{
select DataID
from DTree a 
where not exists (select DataID from DTreeAncestors where DataID = a.DataID and AncestorID = $enterpriseID) 
    and OwnerID = $enterpriseVolumeID and DataID <> $enterpriseID and rownum = 1

select TOP 1 DataID
from DTree a 
where not exists (select DataID from DTreeAncestors where DataID = a.DataID and AncestorID = $enterpriseID) 
    and OwnerID = $enterpriseVolumeID and DataID <> $enterpriseID
}}}

= Authorization Queries =

These queries are executed when authorizing users for search results.

  # Checks whether the search user has permission for the items with the given object IDs. The optional conditions correspond to exclusions in the traversal. The first optional condition excludes the Undelete workspace. The second optional condition excludes the workflow volume. The third optional condition excludes hidden items, and it has nested optional conditions if Items to Index are specified.
{{{
select DataID, PermID from WebNodes a where DataID in ($objectIDs)
    [ and ParentID <> $undeleteVolumeID ]
    [ and OwnerID <> $workflowVolumeID ]
    [ and Catalog <> 2
      and DataID not in (select Anc.DataID
                         from DTreeAncestors Anc join DTree T on Anc.AncestorID = T.DataID
                         where Anc.DataID = a.DataID
                             and T.Catalog = 2
                             [ and Anc.AncestorID not in ($includedLocationNodes)
                               and Anc.AncestorID not in (select AncestorID
                                                          from DTreeAncestors
                                                          where DataID in ($ancestorNodes))
                             ]
                        )
    ]
}}}
  # Determines the Undelete and workflow volume IDs. The optional condition checks the excluded object IDs for the found volume ID.
{{{
select DataID, PermID from DTree a where SubType = $volumeSubType
    [ and DataID in ($excludedLocationNodes) ]
}}}

= Traversal Queries =

These queries are executed when indexing content. The traversal runs in batches, in modification date order. The default batch size is 200, up to a configurable maximum of 500.

  # Find the latest event in the audit trail so that we do not process older delete events. The first query is used with Oracle, and the second with SQL Server.
{{{
select TO_CHAR(AuditDate, 'YYYY-MM-DD HH24:MI:SS') as AuditDate
from DAuditNew a
where EventID in (select max(EventID) from DAuditNew)

select CONVERT(VARCHAR(23), AuditDate, 121) as AuditDate
from DAuditNew a
where EventID in (select max(EventID) from DAuditNew)
}}}
  # Gets candidates for the next batch. The traversal queries are split into two, one gets candidate batches of the appropriate size, and the other applies permissions and the configured restrictions such as Items to Index and the advanced configuration of included and excluded types and items. This avoids a large multi-join across full tables. The optional conditions are used except when starting a new traversal. The first query is used with Oracle, and the second with SQL Server. The Oracle query uses TO_DATE instead of TIMESTAMP literals to preserve support for Oracle 8i.
{{{
select ModifyDate, DataID
from (select * from DTree order by ModifyDate, DataID)
where
    [ (ModifyDate > TO_DATE($modifyDate, 'YYYY-MM-DD HH24:MI:SS') 
       or (ModifyDate = TO_DATE($modifyDate, 'YYYY-MM-DD HH24:MI:SS') and DataID > $dataID))
      and
    ]
    rownum <= $batchSize

select top $batchSize ModifyDate, DataID
from DTree
where
    [ 1=1
    | (ModifyDate > $modifyDate 
       or (ModifyDate = $modifyDate and DataID > $dataID))
    ]
order by ModifyDate, DataID
}}}
  # Second query of the traversal, applying restrictions to the candidates from the first query.
{{{
select DataID, ModifyDate, MimeType, Name, DComment, CreateDate, OwnerName,
    SubType, OwnerID, UserID, DataSize, PermID
from WebNodes a
where DataID in ($candidates)
    [ and (DataID in ($ancestorNodes)
           or DataID in (select DataID
                         from DTreeAncestors
                         where DataID in ($candidates) and AncestorID in ($ancestorNodes)))
    | [ and -OwnerID not in (select DataID from DTree where SubType in ($excludedVolumeTypes)) ]
    ]
    [ and SubType not in ($excludedNodeTypes) ]
    [ and DataID not in (select DataID 
                         from DTreeAncestors
                         where DataID in ($candidates) and AncestorID in ($excludedLocationNodes)) ]
order by ModifyDate, DataID
}}}
  # Gets items to be deleted, based on the audit trail.  The first query is used with Oracle, and the second with SQL Server.
{{{
select TO_CHAR(AuditDate, 'YYYY-MM-DD HH24:MI:SS') as AuditDate, EvenID, DataID
from (select * from DAuditNew order by AuditDate, EventID)
where AuditID = 2
    and (AuditDate > TO_DATE($deleteDate, 'YYYY-MM-DD HH24:MI:SS') 
         or (AuditDate = TO_DATE($deleteDate, 'YYYY-MM-DD HH24:MI:SS') and EventID > $eventID))
    [ and SubType not in ($excludedNodeTypes) ]
    and rownum <= $batchSize

select top $batchSize CONVERT(VARCHAR(23), AuditDate, 121) as AuditDate, EventID, DataID
from DAuditNew
where AuditID = 2
    and (AuditDate > $deleteDate 
         or (AuditDate = $deleteDate and EventID > $eventID))
    [ and SubType not in ($excludedNodeTypes) ]
order by ModifyDate, DataID
}}}